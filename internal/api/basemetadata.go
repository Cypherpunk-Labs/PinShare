//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// BaseMetadata Holds all metadata for a single file, representing the state in the CRDT store.
type BaseMetadata struct {
	// AddedAt Timestamp when the record was first added to the store.
	AddedAt *time.Time `json:"addedAt,omitempty"`

	// FileSHA256 Primary key for the metadata, the SHA256 hash of the file content.
	FileSHA256 string `json:"fileSHA256"`

	// FileType The MIME type of the file.
	FileType string `json:"fileType"`

	// IpfsCID The IPFS Content Identifier (CID) for the file.
	IpfsCID string `json:"ipfsCID"`

	// LastUpdated Timestamp for the last update to this record (LWW clock).
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// ModerationVotes A PN-Counter for community votes to remove the file.
	ModerationVotes *int `json:"moderationVotes,omitempty"`

	// Tags An OR-Set of tags. Keys are the tags, value is always true.
	Tags *map[string]bool `json:"tags,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code An optional application-specific error code.
	Code *int32 `json:"code,omitempty"`

	// Message A human-readable error message.
	Message string `json:"message"`
}

// P2PStatus Information about the local P2P node.
type P2PStatus struct {
	// Addresses The listening multiaddresses of the local node.
	Addresses []string `json:"addresses"`

	// ConnectedPeers The number of currently connected peers.
	ConnectedPeers int `json:"connectedPeers"`

	// Id The Peer ID of the local node.
	Id string `json:"id"`
}

// WritableMetadata The set of fields that can be written by a client when adding or updating a file's metadata.
type WritableMetadata struct {
	// FileType The MIME type of the file.
	FileType string `json:"fileType"`

	// IpfsCID The IPFS Content Identifier (CID) for the file.
	IpfsCID string `json:"ipfsCID"`
}

// AddTagJSONBody defines parameters for AddTag.
type AddTagJSONBody struct {
	// Tag The tag to add.
	Tag string `json:"tag"`
}

// ConnectToPeerJSONBody defines parameters for ConnectToPeer.
type ConnectToPeerJSONBody struct {
	// Multiaddr The full multiaddress of the peer (e.g., /ip4/127.0.0.1/tcp/4001/p2p/12D3Koo...).
	Multiaddr string `json:"multiaddr"`
}

// SendDirectMessageJSONBody defines parameters for SendDirectMessage.
type SendDirectMessageJSONBody struct {
	// Message The text message to send.
	Message string `json:"message"`
}

// AddOrUpdateFileJSONRequestBody defines body for AddOrUpdateFile for application/json ContentType.
type AddOrUpdateFileJSONRequestBody = WritableMetadata

// AddTagJSONRequestBody defines body for AddTag for application/json ContentType.
type AddTagJSONRequestBody AddTagJSONBody

// ConnectToPeerJSONRequestBody defines body for ConnectToPeer for application/json ContentType.
type ConnectToPeerJSONRequestBody ConnectToPeerJSONBody

// SendDirectMessageJSONRequestBody defines body for SendDirectMessage for application/json ContentType.
type SendDirectMessageJSONRequestBody SendDirectMessageJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all file metadata
	// (GET /files)
	ListAllFiles(w http.ResponseWriter, r *http.Request)
	// Get file metadata by SHA256
	// (GET /files/{fileSHA256})
	GetFileBySHA256(w http.ResponseWriter, r *http.Request, fileSHA256 string)
	// Add or update file metadata (Upsert)
	// (PUT /files/{fileSHA256})
	AddOrUpdateFile(w http.ResponseWriter, r *http.Request, fileSHA256 string)
	// Add a tag to a file
	// (POST /files/{fileSHA256}/tags)
	AddTag(w http.ResponseWriter, r *http.Request, fileSHA256 string)
	// Remove a tag from a file
	// (DELETE /files/{fileSHA256}/tags/{tagName})
	RemoveTag(w http.ResponseWriter, r *http.Request, fileSHA256 string, tagName string)
	// Vote for file removal
	// (POST /files/{fileSHA256}/votes/removal)
	VoteForRemoval(w http.ResponseWriter, r *http.Request, fileSHA256 string)
	// List connected peers
	// (GET /p2p/peers)
	ListP2PPeers(w http.ResponseWriter, r *http.Request)
	// Connect to a peer
	// (POST /p2p/peers)
	ConnectToPeer(w http.ResponseWriter, r *http.Request)
	// Send a direct message to a peer
	// (POST /p2p/peers/{peerID}/message)
	SendDirectMessage(w http.ResponseWriter, r *http.Request, peerID string)
	// Get P2P node status
	// (GET /p2p/status)
	GetP2PStatus(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAllFiles operation middleware
func (siw *ServerInterfaceWrapper) ListAllFiles(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAllFiles(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFileBySHA256 operation middleware
func (siw *ServerInterfaceWrapper) GetFileBySHA256(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fileSHA256" -------------
	var fileSHA256 string

	err = runtime.BindStyledParameterWithOptions("simple", "fileSHA256", r.PathValue("fileSHA256"), &fileSHA256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileSHA256", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFileBySHA256(w, r, fileSHA256)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddOrUpdateFile operation middleware
func (siw *ServerInterfaceWrapper) AddOrUpdateFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fileSHA256" -------------
	var fileSHA256 string

	err = runtime.BindStyledParameterWithOptions("simple", "fileSHA256", r.PathValue("fileSHA256"), &fileSHA256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileSHA256", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddOrUpdateFile(w, r, fileSHA256)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddTag operation middleware
func (siw *ServerInterfaceWrapper) AddTag(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fileSHA256" -------------
	var fileSHA256 string

	err = runtime.BindStyledParameterWithOptions("simple", "fileSHA256", r.PathValue("fileSHA256"), &fileSHA256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileSHA256", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTag(w, r, fileSHA256)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RemoveTag operation middleware
func (siw *ServerInterfaceWrapper) RemoveTag(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fileSHA256" -------------
	var fileSHA256 string

	err = runtime.BindStyledParameterWithOptions("simple", "fileSHA256", r.PathValue("fileSHA256"), &fileSHA256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileSHA256", Err: err})
		return
	}

	// ------------- Path parameter "tagName" -------------
	var tagName string

	err = runtime.BindStyledParameterWithOptions("simple", "tagName", r.PathValue("tagName"), &tagName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tagName", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveTag(w, r, fileSHA256, tagName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// VoteForRemoval operation middleware
func (siw *ServerInterfaceWrapper) VoteForRemoval(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "fileSHA256" -------------
	var fileSHA256 string

	err = runtime.BindStyledParameterWithOptions("simple", "fileSHA256", r.PathValue("fileSHA256"), &fileSHA256, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fileSHA256", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VoteForRemoval(w, r, fileSHA256)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListP2PPeers operation middleware
func (siw *ServerInterfaceWrapper) ListP2PPeers(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListP2PPeers(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ConnectToPeer operation middleware
func (siw *ServerInterfaceWrapper) ConnectToPeer(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ConnectToPeer(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SendDirectMessage operation middleware
func (siw *ServerInterfaceWrapper) SendDirectMessage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "peerID" -------------
	var peerID string

	err = runtime.BindStyledParameterWithOptions("simple", "peerID", r.PathValue("peerID"), &peerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "peerID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SendDirectMessage(w, r, peerID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetP2PStatus operation middleware
func (siw *ServerInterfaceWrapper) GetP2PStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetP2PStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/files", wrapper.ListAllFiles)
	m.HandleFunc("GET "+options.BaseURL+"/files/{fileSHA256}", wrapper.GetFileBySHA256)
	m.HandleFunc("PUT "+options.BaseURL+"/files/{fileSHA256}", wrapper.AddOrUpdateFile)
	m.HandleFunc("POST "+options.BaseURL+"/files/{fileSHA256}/tags", wrapper.AddTag)
	m.HandleFunc("DELETE "+options.BaseURL+"/files/{fileSHA256}/tags/{tagName}", wrapper.RemoveTag)
	m.HandleFunc("POST "+options.BaseURL+"/files/{fileSHA256}/votes/removal", wrapper.VoteForRemoval)
	m.HandleFunc("GET "+options.BaseURL+"/p2p/peers", wrapper.ListP2PPeers)
	m.HandleFunc("POST "+options.BaseURL+"/p2p/peers", wrapper.ConnectToPeer)
	m.HandleFunc("POST "+options.BaseURL+"/p2p/peers/{peerID}/message", wrapper.SendDirectMessage)
	m.HandleFunc("GET "+options.BaseURL+"/p2p/status", wrapper.GetP2PStatus)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
